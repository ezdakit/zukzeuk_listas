name: Zerrendaren_Deskarga

on:
  schedule:
    - cron: "0 * * * *"   # Cada 60 minutos
  workflow_dispatch:

permissions:
  contents: write

jobs:
  actualizar:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Descargar elcano.m3u desde múltiples gateways IPFS
        id: elcano_descarga
        run: |
          URLS=(
            "https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr.ipns.dweb.link/hashes.m3u"
            "https://cloudflare-ipfs.com/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://gateway.pinata.cloud/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
          )
          success=false
          for url in "${URLS[@]}"; do
            if curl -L -A "Mozilla/5.0" --max-time 20 "$url" -o elcano_tmp.m3u; then
              if [ -s elcano_tmp.m3u ] && grep -q "^#EXTM3U" elcano_tmp.m3u; then
                 success=true; break
              fi
            fi
            sleep 2
          done
          if [ "$success" != true ]; then
            echo "downloaded=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ -f elcano.m3u ] && cmp -s elcano_tmp.m3u elcano.m3u; then
            echo "changed=false" >> $GITHUB_OUTPUT
            rm elcano_tmp.m3u
          else
            mv elcano_tmp.m3u elcano.m3u
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Descargar new_era.m3u desde múltiples gateways IPFS
        id: newera_descarga
        run: |
          URLS=(
            "https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004.ipns.dweb.link/data/listas/lista_iptv.m3u"
            "https://cloudflare-ipfs.com/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://gateway.pinata.cloud/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
          )
          success=false
          for url in "${URLS[@]}"; do
            if curl -L -A "Mozilla/5.0" --max-time 20 "$url" -o new_era_tmp.m3u; then
              if [ -s new_era_tmp.m3u ] && grep -q "^#EXTM3U" new_era_tmp.m3u; then
                 success=true; break
              fi
            fi
            sleep 2
          done
          if [ "$success" != true ]; then
            echo "downloaded=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ -f new_era.m3u ] && cmp -s new_era_tmp.m3u new_era.m3u; then
            echo "changed=false" >> $GITHUB_OUTPUT
            rm new_era_tmp.m3u
          else
            mv new_era_tmp.m3u new_era.m3u
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Generar ezdakit.m3u fusionando listas
        id: ezdakit_generar
        run: |
          python3 << 'EOF'
          import re
          import csv
          from pathlib import Path

          # 1. CARGAR LISTA NEGRA
          blacklist_map = {}
          blacklist_path = Path("canales/lista_negra.csv")
          
          if blacklist_path.exists():
              try:
                  with blacklist_path.open(mode='r', encoding='utf-8', errors='ignore') as f:
                      reader = csv.DictReader(f)
                      for row in reader:
                          aid = row.get('ace_id', '').strip()
                          real = row.get('canal_real', '').strip()
                          if aid:
                              blacklist_map[aid] = real
                  print(f"Lista negra cargada: {len(blacklist_map)} entradas.")
              except Exception as e:
                  print(f"Error leyendo lista negra: {e}")
          else:
              print("No se encontró canales/lista_negra.csv, se continúa sin filtro.")

          # 2. FUNCIÓN PARSEO
          def parse_m3u(path_obj, source_letter):
              items = []
              if not path_obj.exists(): return items
              content = path_obj.read_text(encoding='utf-8', errors='ignore')
              lines = content.splitlines()
              
              i = 0
              while i < len(lines):
                  line = lines[i].strip()
                  if line.startswith("#EXTINF"):
                      extinf = line
                      url = None
                      j = i + 1
                      while j < len(lines):
                          next_line = lines[j].strip()
                          if next_line and not next_line.startswith("#"):
                              url = next_line
                              break
                          j += 1
                      if not url:
                          i += 1; continue

                      m_ace = re.search(r"(?:acestream://|id=|/)([0-9a-fA-F]{40})", url)
                      if m_ace:
                          ace_id = m_ace.group(1)
                          
                          # Extraer tvg-id
                          m_id = re.search(r'tvg-id="([^"]+)"', extinf)
                          tvgid = m_id.group(1).strip() if m_id and m_id.group(1).strip() else "Unknown"
                          
                          # Extraer nombre original (lo que va después de la última coma)
                          original_name = extinf.split(',')[-1].strip()
                          
                          # Extraer group-title
                          m_group = re.search(r'group-title="([^"]+)"', extinf)
                          group_title = m_group.group(1) if m_group else "OTROS"
                          
                          items.append((tvgid, ace_id, url, source_letter, group_title, original_name))
                      i = j 
                  i += 1
              return items

          # 3. LEER LISTAS
          items_newera = parse_m3u(Path("new_era.m3u"), "N")
          items_elcano = parse_m3u(Path("elcano.m3u"), "E")

          # 4. CREAR REFERENCIAS DE "NEW_ERA" (La lista buena)
          merged = {}
          new_era_names = {} # Mapa Nombre -> TVG-ID

          for tvgid, ace, url, src, grp, ori_name in items_newera:
              # Guardamos en merged directamente (prioridad New Era)
              merged[ace] = (tvgid, ace, url, src, grp, ori_name)
              
              # Guardamos referencia para reparar Elcano
              if tvgid != "Unknown":
                  new_era_names[ori_name] = tvgid

          # 5. PROCESAR "ELCANO" (La lista que puede fallar)
          for tvgid, ace, url, src, grp, ori_name in items_elcano:
              # Si el ID ya está en merged (venía de New Era), lo ignoramos (prioridad New Era)
              if ace in merged:
                  continue
              
              # Si es nuevo, verificamos si hay que reparar el TVG-ID
              final_tvgid = tvgid
              if final_tvgid == "Unknown" or not final_tvgid:
                  # Intentamos buscar por nombre en la lista de New Era
                  if ori_name in new_era_names:
                      final_tvgid = new_era_names[ori_name]

              merged[ace] = (final_tvgid, ace, url, src, grp, ori_name)

          # 6. GENERAR LISTA FINAL
          final_items = []
          for tvgid, ace, url, src, grp, ori_name in merged.values():
              prefix = ace[:3]
              
              # --- NUEVA LÓGICA DE CALIDAD ---
              u_name = ori_name.upper()
              if "4K" in u_name or "UHD" in u_name:
                  quality_suffix = " (UHD)"
              elif "1080" in u_name or "FHD" in u_name:
                  quality_suffix = " (FHD)"
              else:
                  quality_suffix = " (HD)"

              # Generar nombre base
              if tvgid == "Unknown":
                  base_name = f"{ori_name} ({src}-{prefix}){quality_suffix}"
              else:
                  # Quitamos " HD" si existe para limpiar el nombre y evitar duplicar el (HD)
                  norm = tvgid[:-3] if tvgid.endswith(" HD") else tvgid
                  base_name = f"{norm} ({src}-{prefix}){quality_suffix}"
              
              # --- LÓGICA DE LISTA NEGRA ---
              final_group = grp
              final_name = base_name

              if ace in blacklist_map:
                  # 1. Cambiar grupo
                  final_group = "ZZ_Canales_KO"
                  
                  # 2. Comprobar canal_real y modificar nombre si existe
                  real_channel = blacklist_map[ace]
                  if real_channel:
                      final_name = f"{base_name} >>> {real_channel}"
              
              new_extinf = f'#EXTINF:-1 tvg-id="{tvgid}" tvg-name="{final_name}" group-title="{final_group}",{final_name}'
              final_items.append((tvgid if tvgid != "Unknown" else final_name, new_extinf, url))

          # Ordenar alfabéticamente
          final_items.sort(key=lambda x: x[0])
          
          header = "#EXTM3U url-tvg=\"https://raw.githubusercontent.com/davidmuma/EPG_dobleM/refs/heads/master/guiatv.xml,https://epgshare01.online/epgshare01/epg_ripper_NL1.xml.gz,https://raw.githubusercontent.com/davidmuma/EPG_dobleM/master/guiatv.xml\" refresh=\"3600\""
          output_path = Path("ezdakit.m3u")
          new_content = header + "\n" + "\n".join([f"{ei}\n{u}" for _, ei, u in final_items])
          
          changed = True
          if output_path.exists() and output_path.read_text(encoding='utf-8') == new_content:
              changed = False
          
          if changed:
              output_path.write_text(new_content, encoding="utf-8")
              print("changed=true")
          else:
              print("changed=false")
          EOF
          echo "changed=$(python3 -c "import sys; print('true') if 'changed=true' in sys.stdin.read() else print('false')" << 'EOF'
          $(cat)
          EOF
          )" >> $GITHUB_OUTPUT

      - name: Guardar histórico y Push
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          mkdir -p history
          [ -f elcano.m3u ] && cp elcano.m3u "history/elcano_$(date +%F_%H-%M).m3u"
          [ -f new_era.m3u ] && cp new_era.m3u "history/new_era_$(date +%F_%H-%M).m3u"
          [ -f ezdakit.m3u ] && cp ezdakit.m3u "history/ezdakit_$(date +%F_%H-%M).m3u"
          ls -1t history/*.m3u | tail -n +151 | xargs -r rm
          git add .
          git diff --staged --quiet || (git commit -m "Update lists $(date +'%Y-%m-%d %H:%M')" && git push)
