name: Zerrendaren_Deskarga

on:
  schedule:
    - cron: "0 * * * *"   # Cada 60 minutos
  workflow_dispatch:

jobs:
  actualizar:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Descargar elcano.m3u desde múltiples gateways IPFS
        id: elcano_descarga
        run: |
          URLS=(
            "https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr.ipns.dweb.link/hashes.m3u"
            "https://cloudflare-ipfs.com/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://cf-ipfs.com/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.runfission.com/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://gateway.pinata.cloud/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.infura.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.eth.aragon.network/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.decentralized-content.com/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.fleek.co/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.4everland.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
            "https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes.m3u"
          )

          success=false

          for url in "${URLS[@]}"; do
            echo "Intentando descargar elcano desde: $url"
            for i in {1..3}; do
              curl -L --max-time 20 "$url" -o elcano_tmp.m3u && break
              echo "Intento $i fallido para $url"
              sleep 5
            done
            if [ -s elcano_tmp.m3u ]; then
              echo "Descarga correcta elcano desde: $url"
              success=true
              break
            fi
          done

          if [ "$success" != true ]; then
            echo "::error title=Descarga elcano fallida::Ninguno de los gateways IPFS respondió correctamente"
            echo "downloaded=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if ! grep -q "^#EXTM3U" elcano_tmp.m3u; then
            echo "::error title=Archivo elcano inválido::El archivo descargado NO es un M3U válido"
            echo "downloaded=false" >> $GITHUB_OUTPUT
            rm elcano_tmp.m3u
            exit 0
          fi

          changed=true
          if [ -f elcano.m3u ]; then
            if cmp -s elcano_tmp.m3u elcano.m3u; then
              echo "Elcano sin cambios"
              changed=false
              rm elcano_tmp.m3u
            fi
          fi

          if [ "$changed" = true ]; then
            mv elcano_tmp.m3u elcano.m3u
            echo "downloaded=true" >> $GITHUB_OUTPUT
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "downloaded=true" >> $GITHUB_OUTPUT
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Guardar histórico elcano (máximo 50)
        if: steps.elcano_descarga.outputs.changed == 'true'
        run: |
          mkdir -p history
          timestamp=$(date +"%Y-%m-%d_%H-%M")
          cp elcano.m3u "history/elcano_$timestamp.m3u"

          total=$(ls history/elcano_*.m3u 2>/dev/null | wc -l || echo 0)
          if [ "$total" -gt 50 ]; then
            excess=$((total - 50))
            echo "Eliminando $excess históricos antiguos de elcano"
            ls -1t history/elcano_*.m3u | tail -n "$excess" | xargs -I {} rm "{}"
          fi

      - name: Descargar new_era.m3u desde múltiples gateways IPFS
        id: newera_descarga
        run: |
          URLS=(
            "https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004.ipns.dweb.link/data/listas/lista_iptv.m3u"
            "https://cloudflare-ipfs.com/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://cf-ipfs.com/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.runfission.com/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://gateway.pinata.cloud/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.infura.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.eth.aragon.network/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.decentralized-content.com/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.fleek.co/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.4everland.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
            "https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_iptv.m3u"
          )

          success=false

          for url in "${URLS[@]}"; do
            echo "Intentando descargar new_era desde: $url"
            for i in {1..3}; do
              curl -L --max-time 20 "$url" -o new_era_tmp.m3u && break
              echo "Intento $i fallido para $url"
              sleep 5
            done
            if [ -s new_era_tmp.m3u ]; then
              echo "Descarga correcta new_era desde: $url"
              success=true
              break
            fi
          done

          if [ "$success" != true ]; then
            echo "::error title=Descarga new_era fallida::Ninguno de los gateways IPFS respondió correctamente"
            echo "downloaded=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if ! grep -q "^#EXTM3U" new_era_tmp.m3u; then
            echo "::error title=Archivo new_era inválido::El archivo descargado NO es un M3U válido"
            echo "downloaded=false" >> $GITHUB_OUTPUT
            rm new_era_tmp.m3u
            exit 0
          fi

          changed=true
          if [ -f new_era.m3u ]; then
            if cmp -s new_era_tmp.m3u new_era.m3u; then
              echo "new_era sin cambios"
              changed=false
              rm new_era_tmp.m3u
            fi
          fi

          if [ "$changed" = true ]; then
            mv new_era_tmp.m3u new_era.m3u
            echo "downloaded=true" >> $GITHUB_OUTPUT
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "downloaded=true" >> $GITHUB_OUTPUT
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Guardar histórico new_era (máximo 50)
        if: steps.newera_descarga.outputs.changed == 'true'
        run: |
          mkdir -p history
          timestamp=$(date +"%Y-%m-%d_%H-%M")
          cp new_era.m3u "history/new_era_$timestamp.m3u"

          total=$(ls history/new_era_*.m3u 2>/dev/null | wc -l || echo 0)
          if [ "$total" -gt 50 ]; then
            excess=$((total - 50))
            echo "Eliminando $excess históricos antiguos de new_era"
            ls -1t history/new_era_*.m3u | tail -n "$excess" | xargs -I {} rm "{}"
          fi

      - name: Generar ezdakit.m3u fusionando elcano y new_era (Python)
        id: ezdakit_generar
        run: |
          python3 << 'EOF'
          import re
          import os
          from pathlib import Path

          elcano = Path("elcano.m3u")
          newera = Path("new_era.m3u")

          if not elcano.exists() or not newera.exists():
              print("generated=false")
              exit(0)

          def parse_m3u(path, source_letter):
              items = []
              lines = path.read_text(errors="ignore").splitlines()
              i = 0
              while i < len(lines):
                  line = lines[i].strip()
                  if line.startswith("#EXTINF"):
                      extinf = line
                      if i + 1 < len(lines):
                          url = lines[i+1].strip()
                      else:
                          i += 1
                          continue
                      m_ace = re.search(r"acestream://([0-9a-fA-F]+)", url)
                      if not m_ace:
                          i += 1
                          continue
                      ace_id = m_ace.group(1)
                      m_id = re.search(r'tvg-id="([^"]+)"', extinf)
                      if not m_id:
                          i += 1
                          continue
                      tvgid = m_id.group(1)
                      items.append((tvgid, ace_id, extinf, url, source_letter))
                  i += 1
              return items

          items_elcano = parse_m3u(elcano, "E")
          items_newera = parse_m3u(newera, "N")

          merged = {}
          for tvgid, ace, ext, url, src in items_elcano + items_newera:
              if ace not in merged:
                  merged[ace] = (tvgid, ace, ext, url, src)

          final_items = []
          for tvgid, ace, ext, url, src in merged.values():
              norm = tvgid[:-3] if tvgid.endswith(" HD") else tvgid
              prefix = ace[:3]
              name = f"{norm} [{src}-{prefix}]"
              extinf = f'#EXTINF:-1 tvg-id="{tvgid}" tvg-name="{name}" group-title="",{name}'
              final_items.append((tvgid, extinf, url))

          final_items.sort(key=lambda x: x[0])

          header = elcano.read_text(errors="ignore").splitlines()[0]
          output = [header]
          for _, extinf, url in final_items:
              output.append(extinf)
              output.append(url)

          Path("ezdakit_tmp.m3u").write_text("\n".join(output), encoding="utf-8")

          if Path("ezdakit.m3u").exists():
              old = Path("ezdakit.m3u").read_text(errors="ignore")
              new = Path("ezdakit_tmp.m3u").read_text(errors="ignore")
              if old == new:
                  print("ezdakit sin cambios")
                  os.remove("ezdakit_tmp.m3u")
                  print("generated=true")
                  print("changed=false")
                  exit(0)

          os.replace("ezdakit_tmp.m3u", "ezdakit.m3u")
          print("generated=true")
          print("changed=true")
          EOF

      - name: Guardar histórico ezdakit (máximo 50)
        if: steps.ezdakit_generar.outputs.changed == 'true'
        run: |
          mkdir -p history
          timestamp=$(date +"%Y-%m-%d_%H-%M")
          cp ezdakit.m3u "history/ezdakit_$timestamp.m3u"

          total=$(ls history/ezdakit_*.m3u 2>/dev/null | wc -l || echo 0)
          if [ "$total" -gt 50 ]; then
            excess=$((total - 50))
            echo "Eliminando $excess históricos antiguos de ezdakit"
            ls -1t history/ezdakit_*.m3u | tail -n "$excess" | xargs -I {} rm "{}"
          fi

      - name: Configurar Git
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"

      - name: Commit y push
        run: |
          git add elcano.m3u new_era.m3u ezdakit.m3u || true
          git add history/ || true

          git diff --cached --quiet || git commit -m "Actualización automática de listas IPTV"
          git push

      - name: Notificación final
        run: |
          echo "::notice title=Workflow completado::Actualización y fusión de listas IPTV finalizada"
